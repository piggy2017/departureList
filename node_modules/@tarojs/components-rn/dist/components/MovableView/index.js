/* eslint-disable @typescript-eslint/no-empty-function */
import * as React from 'react';
import { PanResponder, Animated } from 'react-native';
import View from '../View';
class _MovableView extends React.Component {
    constructor(props) {
        super(props);
        this.$ref = React.createRef();
        this.createPanResponder = () => {
            this.panResponder = PanResponder.create({
                onMoveShouldSetPanResponder: () => !this.state.disabled,
                onMoveShouldSetPanResponderCapture: () => !this.state.disabled,
                onPanResponderGrant: () => {
                    const { pan } = this.state;
                    pan.setOffset({ x: pan.x._value, y: pan.y._value });
                    this.props.onDragStart && this.props.onDragStart();
                },
                onPanResponderMove: (e, gestureState) => {
                    Animated.event([
                        null,
                        Object.assign(Object.assign({}, (this.props.direction !== 'none' && this.props.direction !== 'vertical' ? { dx: this.state.pan.x } : {})), (this.props.direction !== 'none' && this.props.direction !== 'horizontal' ? { dy: this.state.pan.y } : {}))
                    ], {
                        useNativeDriver: false
                    })(e, gestureState);
                    this.props.onChange && this.props.onChange(e);
                },
                onPanResponderRelease: () => {
                    const { pan } = this.state;
                    const { layout = { width: 0, height: 0 } } = this.props;
                    this.state.pan.flattenOffset();
                    const x = pan.x._value > layout.width - this.W ? layout.width - this.W : pan.x._value < 0 ? 0 : pan.x._value;
                    const y = pan.y._value > layout.height - this.H ? layout.height - this.H : pan.y._value < 0 ? 0 : pan.y._value;
                    Animated.spring(this.state.pan, {
                        toValue: { x: x, y: y },
                        useNativeDriver: false
                    }).start();
                    this.props.onDragEnd && this.props.onDragEnd();
                }
            });
        };
        this.changeDisableStatus = () => {
            const { disabled } = this.state;
            this.setState({
                disabled: !disabled
            });
        };
        this._onLayout = (event) => {
            const { width, height } = event.nativeEvent.layout;
            this.W = width;
            this.H = height;
        };
        this.state = {
            pan: new Animated.ValueXY(),
            disabled: props.disabled,
            xOffset: 0,
            yOffset: 0
        };
        this.createPanResponder();
    }
    componentDidMount() {
        const { pan } = this.state;
        const { onMove } = this.props;
        if (typeof onMove === 'function')
            pan.addListener((values) => onMove(values));
    }
    componentWillUnmount() {
        const { pan } = this.state;
        pan.removeAllListeners();
    }
    render() {
        const { style } = this.props;
        return (React.createElement(Animated.View, Object.assign({ ref: this.$ref, onLayout: this._onLayout }, this.panResponder.panHandlers, { style: [style, this.state.pan.getLayout()] }),
            React.createElement(View, null, this.props.children)));
    }
}
_MovableView.defaultProps = {
    direction: 'none',
    onDragStart: () => { },
    onDragEnd: () => { },
    onChange: () => { },
    disabled: false,
    animation: true
};
export default _MovableView;
//# sourceMappingURL=index.js.map