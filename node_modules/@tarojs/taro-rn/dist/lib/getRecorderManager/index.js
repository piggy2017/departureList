var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Audio } from 'expo-av';
import * as Permissions from 'expo-permissions';
import * as FileSystem from 'expo-file-system';
class RecorderManager {
    static getInstance() {
        if (!RecorderManager.instance) {
            RecorderManager.instance = new RecorderManager();
        }
        return RecorderManager.instance;
    }
    /**
     * 开始录音
     * @param {object} opts
     * @param {number} [opts.duration=60000] - 录音的时长，单位 ms，最大值 600000（10 分钟）❓
     * @param {number} [opts.sampleRate=8000] - 采样率
     * @param {number} [opts.numberOfChannels=2] - 录音通道数
     * @param {number} [opts.encodeBitRate=48000] - 编码码率，有效值见下表格
     * @param {string} [opts.format='acc'] - 音频格式 ❌
     * @param {number} [opts.frameSize] - 指定帧大小，单位 KB。传入 frameSize 后，每录制指定帧大小的内容后，会回调录制的文件内容，不指定则不会回调。暂仅支持 mp3 格式。 ❌
     * @param {string} [opts.audioSource='auto'] - 指定录音的音频输入源，可通过 wx.getAvailableAudioSources() 获取当前可用的音频源 ❌
     */
    start(opts = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { status } = yield Permissions.getAsync(Permissions.AUDIO_RECORDING);
            if (status !== 'granted') {
                const { status } = yield Permissions.askAsync(Permissions.AUDIO_RECORDING);
                if (status !== 'granted') {
                    const res = { errMsg: 'Permissions denied!' };
                    return Promise.reject(res);
                }
            }
            const { 
            // duration = 60000,
            sampleRate = 8000, numberOfChannels = 2, encodeBitRate = 48000,
            // format = 'aac',
            // frameSize,
            // audioSource = 'auto'
             } = opts;
            const options = {
                android: Object.assign({}, RecorderManager.RecordingOptions.android, { sampleRate, numberOfChannels, bitRate: encodeBitRate }),
                ios: Object.assign({}, RecorderManager.RecordingOptions.ios, { sampleRate, numberOfChannels, bitRate: encodeBitRate })
            };
            try {
                yield Audio.setAudioModeAsync({
                    allowsRecordingIOS: true,
                    interruptionModeIOS: Audio.INTERRUPTION_MODE_IOS_DO_NOT_MIX,
                    playsInSilentModeIOS: true,
                    staysActiveInBackground: false,
                    shouldDuckAndroid: true,
                    interruptionModeAndroid: Audio.INTERRUPTION_MODE_ANDROID_DO_NOT_MIX,
                    playThroughEarpieceAndroid: true
                });
                if (RecorderManager.recordInstance) {
                    const recordStatus = yield RecorderManager.recordInstance.getStatusAsync();
                    if (recordStatus.canRecord) {
                        yield RecorderManager.recordInstance.stopAndUnloadAsync();
                    }
                    RecorderManager.recordInstance.setOnRecordingStatusUpdate(null);
                    RecorderManager.recordInstance = undefined;
                }
                const recording = new Audio.Recording();
                RecorderManager.recordInstance = recording;
                RecorderManager.recordInstance.setOnRecordingStatusUpdate(this.onRecordingStatusUpdate);
                yield RecorderManager.recordInstance.prepareToRecordAsync(options);
                // const res2 = RecorderManager.recordInstance.getStatusAsync()
                // console.log('res2', res2)
                yield RecorderManager.recordInstance.startAsync();
                (_a = this.onStartCallback) === null || _a === void 0 ? void 0 : _a.call(this);
            }
            catch (error) {
                this.onErrorCallback && this.onErrorCallback({ errMsg: error.message });
            }
        });
    }
    /**
     * 暂停录音
     */
    pause() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const recordInstance = RecorderManager.recordInstance;
                if (recordInstance) {
                    yield recordInstance.pauseAsync();
                    this.onPauseCallback && this.onPauseCallback();
                }
            }
            catch (error) {
                this.onErrorCallback && this.onErrorCallback({ errMsg: error.message });
            }
        });
    }
    /**
     * 继续录音
     * @returns {Promise<void>}
     */
    resume() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const recordInstance = RecorderManager.recordInstance;
                if (recordInstance) {
                    yield recordInstance.startAsync();
                    this.onResumeCallback && this.onResumeCallback();
                }
            }
            catch (error) {
                this.onErrorCallback && this.onErrorCallback({ errMsg: error.message });
            }
        });
    }
    /**
     * 停止录音
     * @returns {Promise<void>}
     */
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const recordInstance = RecorderManager.recordInstance;
                if (recordInstance) {
                    const recordStatus = yield recordInstance.stopAndUnloadAsync();
                    const uri = recordInstance.getURI() || '';
                    const info = yield FileSystem.getInfoAsync(uri);
                    // console.log(`FILE INFO: ${JSON.stringify(info)}`)
                    const result = { tempFilePath: uri, duration: recordStatus.durationMillis, fileSize: info.size };
                    this.onStopCallback && this.onStopCallback(result);
                }
            }
            catch (error) {
                this.onErrorCallback && this.onErrorCallback({ errMsg: error.message });
            }
        });
    }
    onRecordingStatusUpdate(status) {
        if (this.preStatus === undefined) {
            this.preStatus = status;
            return;
        }
        if (!this.preStatus.isRecording && status.isRecording) {
            console.log('start');
        }
    }
    /**
     * 监听录音开始事件
     * @param {function} callback
     */
    onError(callback) {
        this.onErrorCallback = callback;
    }
    /**
     * 监听录音开始事件
     * @param {function} callback
     */
    onStart(callback) {
        this.onStartCallback = callback;
    }
    /**
     * 监听录音结束事件
     * @param {function} callback
     */
    onStop(callback) {
        this.onStopCallback = callback;
    }
    /**
     * 监听录音暂停事件
     * @param {function} callback
     */
    onPause(callback) {
        this.onPauseCallback = callback;
    }
    /**
     * 监听录音继续事件
     * @param {function} callback
     */
    onResume(callback) {
        this.onResumeCallback = callback;
    }
}
RecorderManager.RecordingOptions = {
    android: {
        extension: '.m4a',
        outputFormat: Audio.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4,
        audioEncoder: Audio.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC,
        sampleRate: 8000,
        numberOfChannels: 2,
        bitRate: 48000
    },
    ios: {
        extension: '.caf',
        audioQuality: Audio.RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX,
        sampleRate: 8000,
        numberOfChannels: 2,
        bitRate: 48000,
        linearPCMBitDepth: 16,
        linearPCMIsBigEndian: false,
        linearPCMIsFloat: false
    }
};
/**
 * 获取全局唯一的录音管理器 RecorderManager
 * @returns {RecorderManager}
 */
function getRecorderManager() {
    return RecorderManager.getInstance();
}
export { getRecorderManager };
//# sourceMappingURL=index.js.map